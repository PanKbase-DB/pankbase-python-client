'use strict';

/* eslint-disable sort-keys */

// since our usage is fairly narrow, we don't really need to install extra deps such ast-types or @babel/types.
// the set of builders I've prepared here should be sufficient for our needs

function program(body) {
  return {
    type: 'Program',
    body,
  };
}

function blockStatement(body, directives) {
  return {
    type: 'BlockStatement',
    body,
    directives,
  };
}

function expressionStatement(expression) {
  return {
    type: 'ExpressionStatement',
    expression,
  };
}

function literal(value) {
  return typeof value === 'number'
    ? numericLiteral(value)
    : stringLiteral(value);
}

function stringLiteral(value) {
  return {
    type: 'StringLiteral',
    value,
  };
}

function booleanLiteral(value) {
  return {
    type: 'BooleanLiteral',
    value,
  };
}

function numericLiteral(value) {
  return {
    type: 'NumericLiteral',
    value,
  };
}

function nullLiteral() {
  return {
    type: 'NullLiteral',
    value: null,
  };
}

function regExpLiteral(pattern, flags = '') {
  return {
    type: 'RegExpLiteral',
    pattern,
    flags,
  };
}

function identifier(name) {
  return {
    type: 'Identifier',
    name,
  };
}

function logicalExpression(operator, left, right) {
  return {
    type: 'LogicalExpression',
    operator,
    left,
    right,
  };
}

function ifStatement(test, consequent, alternate) {
  return {
    type: 'IfStatement',
    test,
    consequent,
    alternate,
  };
}

function binaryExpression(operator, left, right) {
  return {
    type: 'BinaryExpression',
    operator,
    left,
    right,
  };
}

function safeBinaryExpression(operator, left, right) {
  let actualRight = right;

  if (
    right.type === 'NumericLiteral' ||
    (right.type === 'StringLiteral' &&
      Number.isSafeInteger(Number(right.value)))
  ) {
    actualRight = stringLiteral(String(right.value));
  }

  return {
    type: 'BinaryExpression',
    operator,
    left:
      actualRight === right
        ? left
        : callExpression(identifier('String'), [left]),
    right: actualRight,
  };
}

function unaryExpression(operator, argument, prefix = true) {
  return {
    type: 'UnaryExpression',
    operator,
    argument,
    prefix,
  };
}

function memberExpression(
  object,
  property,
  computed = false,
  optional = null,
) {
  return {
    type: 'MemberExpression',
    object,
    property,
    computed,
    optional,
  };
}

function assignmentExpression(operator, left, right) {
  return {
    type: 'AssignmentExpression',
    operator,
    left,
    right,
  };
}

function callExpression(callee, _arguments) {
  return {
    type: 'CallExpression',
    callee,
    arguments: _arguments,
  };
}

function functionDeclaration(id, params, body) {
  return {
    type: 'FunctionDeclaration',
    id,
    params,
    body,
  };
}

function returnStatement(argument) {
  return {
    type: 'ReturnStatement',
    argument,
  };
}

function arrayExpression(elements) {
  return {
    type: 'ArrayExpression',
    elements,
  };
}

function objectExpression(properties) {
  return {
    type: 'ObjectExpression',
    properties,
  };
}

function objectMethod(
  kind,
  key,
  params,
  body,
  computed = false,
  generator = false,
  _async = false,
) {
  return {
    type: 'ObjectMethod',
    kind,
    key,
    params,
    body,
    computed,
    generator,
    async: _async,
  };
}

function objectProperty(
  key,
  value,
  computed = false,
  shorthand = false,
  decorators = null,
) {
  return {
    type: 'ObjectProperty',
    key,
    value,
    computed,
    shorthand,
    decorators,
  };
}

function variableDeclaration(kind, declarations) {
  return {
    type: 'VariableDeclaration',
    kind,
    declarations,
  };
}

function variableDeclarator(id, init) {
  return {
    type: 'VariableDeclarator',
    id,
    init,
  };
}

function newExpression(callee, _arguments) {
  return {
    type: 'NewExpression',
    callee,
    arguments: _arguments,
  };
}

function importDeclaration(specifiers, source) {
  return {
    type: 'ImportDeclaration',
    specifiers,
    source,
  };
}

function importSpecifier(local, imported) {
  return {
    type: 'ImportSpecifier',
    local,
    imported,
  };
}

function exportDefaultDeclaration(declaration) {
  return {
    type: 'ExportDefaultDeclaration',
    declaration,
  };
}

function arrowFunctionExpression(params, body, _async = false) {
  return {
    type: 'ArrowFunctionExpression',
    params,
    body,
    async: _async,
  };
}

function tryStatement(block, handler = null, finalizer = null) {
  return {
    type: 'TryStatement',
    block,
    handler,
    finalizer,
  };
}

exports.arrayExpression = arrayExpression;
exports.arrowFunctionExpression = arrowFunctionExpression;
exports.assignmentExpression = assignmentExpression;
exports.binaryExpression = binaryExpression;
exports.blockStatement = blockStatement;
exports.booleanLiteral = booleanLiteral;
exports.callExpression = callExpression;
exports.exportDefaultDeclaration = exportDefaultDeclaration;
exports.expressionStatement = expressionStatement;
exports.functionDeclaration = functionDeclaration;
exports.identifier = identifier;
exports.ifStatement = ifStatement;
exports.importDeclaration = importDeclaration;
exports.importSpecifier = importSpecifier;
exports.literal = literal;
exports.logicalExpression = logicalExpression;
exports.memberExpression = memberExpression;
exports.newExpression = newExpression;
exports.nullLiteral = nullLiteral;
exports.numericLiteral = numericLiteral;
exports.objectExpression = objectExpression;
exports.objectMethod = objectMethod;
exports.objectProperty = objectProperty;
exports.program = program;
exports.regExpLiteral = regExpLiteral;
exports.returnStatement = returnStatement;
exports.safeBinaryExpression = safeBinaryExpression;
exports.stringLiteral = stringLiteral;
exports.tryStatement = tryStatement;
exports.unaryExpression = unaryExpression;
exports.variableDeclaration = variableDeclaration;
exports.variableDeclarator = variableDeclarator;
