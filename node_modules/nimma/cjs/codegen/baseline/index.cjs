'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var builders = require('../ast/builders.cjs');
var index = require('../fast-paths/index.cjs');
var guards = require('../guards.cjs');
var iterator = require('../iterator.cjs');
var emitCall = require('../templates/emit-call.cjs');
var scope = require('../templates/scope.cjs');
var consts = require('../tree/consts.cjs');
var tree = require('../tree/tree.cjs');
var jsonpathHashes = require('../utils/jsonpath-hashes.cjs');
var generators = require('./generators.cjs');

function baseline(jsonPaths) {
  const hashes = new jsonpathHashes.default();
  const tree$1 = new tree.default({
    hashes,
  });

  traverse: for (const [expression, nodes] of jsonPaths) {
    const iterator$1 = new iterator.default(nodes);

    if (iterator$1.length === -1) {
      continue;
    }

    const hash = jsonpathHashes.default.generate(iterator$1.nodes);
    const existingHash = hashes.get(hash);

    if (existingHash !== void 0) {
      const method = tree$1.getMethodByHash(existingHash);
      let body = method.body.body;

      body.push(
        emitCall.default(builders.stringLiteral(expression), iterator$1.modifiers),
      );
      hashes.link(hash, expression);
      continue;
    } else {
      hashes.set(hash, expression);
    }

    if (nodes.length > 0 && guards.isDeep(nodes[0])) {
      tree$1.traversalZones.destroy();
    }

    const ctx = {
      id: builders.stringLiteral(expression),
      iterator: iterator$1,
    };

    tree$1.ctx = ctx;

    for (const fastPath of index.default) {
      if (fastPath(nodes, tree$1, ctx)) {
        continue traverse;
      }
    }

    const branch = [
      builders.ifStatement(
        builders.binaryExpression(
          iterator$1.feedback.fixed && iterator$1.feedback.stateOffset === -1
            ? '!=='
            : '<',
          scope.default.depth,
          builders.numericLiteral(iterator$1.feedback.minimumDepth + 1),
        ),
        builders.returnStatement(),
      ),
    ];

    let zone = tree$1.traversalZones.create();

    for (const node of iterator$1) {
      if (guards.isDeep(node)) {
        zone?.unbind();
        zone = null;
      }

      switch (node.type) {
        case 'MemberExpression':
          generators.generateMemberExpression(branch, iterator$1, node);
          zone?.expand(node.value);
          break;
        case 'MultipleMemberExpression':
          generators.generateMultipleMemberExpression(branch, iterator$1, node);
          zone?.expandMultiple(node.value);
          break;
        case 'SliceExpression':
          generators.generateSliceExpression(branch, iterator$1, node, tree$1);
          zone?.resize();
          break;
        case 'ScriptFilterExpression':
          generators.generateFilterScriptExpression(branch, iterator$1, node, tree$1);
          zone?.resize();
          break;
        case 'WildcardExpression':
          generators.generateWildcardExpression(branch, iterator$1);
          zone?.resize();
          break;
        case 'CustomShorthandExpression':
          generators.generateCustomShorthandExpression(branch, iterator$1, node);
          break;
      }
    }

    branch.push(emitCall.default(ctx.id, iterator$1.modifiers));

    let feedback = consts.NEEDS_TRAVERSAL;
    if (iterator$1.feedback.stateOffset !== -1) {
      feedback |= consts.NEEDS_STATE;
    }
    if (iterator$1.feedback.shorthands > 0) {
      feedback |= consts.NEEDS_SHORTHANDS;
    }

    tree$1.addTreeMethod(ctx.id, builders.blockStatement(branch), feedback);
  }

  return tree$1;
}

exports.default = baseline;
