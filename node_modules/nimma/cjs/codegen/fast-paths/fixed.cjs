'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var builders = require('../ast/builders.cjs');
var guards = require('../guards.cjs');
var emitCall = require('../templates/emit-call.cjs');
var sandbox = require('../templates/sandbox.cjs');
var scope = require('../templates/scope.cjs');

const VALUE_IDENTIFIER = builders.identifier('value');
const IS_OBJECT_IDENTIFIER = builders.identifier('isObject');

const IS_NOT_OBJECT_IF_STATEMENT = builders.ifStatement(
  builders.unaryExpression(
    '!',
    builders.callExpression(IS_OBJECT_IDENTIFIER, [VALUE_IDENTIFIER]),
  ),
  builders.returnStatement(),
);

const IS_NULL_SCOPE_IF_STATEMENT = builders.ifStatement(
  builders.binaryExpression('===', scope.default._, builders.nullLiteral()),
  builders.returnStatement(),
);

function toLiteral(node) {
  return builders.literal(node.value);
}

var fixed = (nodes, tree, ctx) => {
  if (!nodes.every(guards.isMemberExpression) || nodes.some(guards.isDeep)) {
    return false;
  }

  const valueVariableDeclaration = builders.variableDeclaration('const', [
    builders.variableDeclarator(
      VALUE_IDENTIFIER,
      nodes
        .slice(0, -1)
        .reduce(
          (object, node) =>
            builders.memberExpression(object, builders.literal(node.value), true, true),
          sandbox.default.root,
        ),
    ),
  ]);

  tree.addRuntimeDependency(IS_OBJECT_IDENTIFIER.name);

  tree.addTreeMethod(
    ctx.id,
    builders.blockStatement([
      valueVariableDeclaration,
      IS_NOT_OBJECT_IF_STATEMENT,
      builders.expressionStatement(
        builders.assignmentExpression(
          '=',
          scope.default._,
          builders.callExpression(scope.default.fork, [
            builders.arrayExpression(nodes.map(toLiteral)),
          ]),
        ),
      ),
      IS_NULL_SCOPE_IF_STATEMENT,
      emitCall.default(ctx.id, ctx.iterator.modifiers),
    ]),
    0,
  );

  return true;
};

exports.default = fixed;
